# -*- coding: utf-8 -*-
"""Pytorch.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ikO0cE4nkZrD2-dgm0RjhqscjXnE3S7v
"""

import torch
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
print(torch.__version__)

"""##Introduction to Tensors

### Creating tensors
Py torch tensors are created using "torch.Tensor()"
"""

#Scalar
scalar = torch.tensor(7)
scalar

scalar.ndim

#get scalar as an int
scalar.item()

#Vector
vector = torch.tensor([7,7])
vector

#MATRIX
MATRIX = torch.tensor([[7,8],
                      [9,10]])
MATRIX

MATRIX.ndim

MATRIX[1]

MATRIX.shape

#TENSOR
TENSOR = torch.tensor([[[1,2,3],
                        [3,6,9],
                        [2,5,4]]])
TENSOR

TENSOR.ndim

TENSOR.shape

TENSOR[0]

"""scalar = one dimension /
vector = 2 dimensions /
matrix = 3 dimensions /
tensor = any number of dimensions /
scalar and vector are usually lower cased /
matrix and tensor are usually upper cased /

### Random tensors
Why random tensors?
Random tensors are important beacuase neural networks learn with tensors full of random numbers and adjust the random numbers to represent the data better
`start with random numbers => look at data => update random  numbers => look at data => update random numbers`
"""

#Create random tensors of shape (3,4)
random_tensor = torch.rand(size=(3,4))
random_tensor

#Create a random tensor with similar shape to an image tensor
random_image_size_tensor = torch.rand(size=(3,224,224)) #color channel(rgb), height, width,
random_image_size_tensor.shape, random_image_size_tensor.ndim

"""### Zeros and ones"""

# Create a tensor of all zeros
zeros = torch.zeros(size=(3,4))
zeros
zeros * random_tensor

# Create a tensor with all ones
ones = torch.ones(size=(3,4))
ones

"""### Creating a range of tensors and tensors-like"""

# Use torch.arange()
one_to_ten = torch.arange(start=1, end=11, step=1) # 0 indexed max excluded
one_to_ten

#Creating tensors like, a tensor like something else
ten_zeros = torch.zeros_like(input=one_to_ten)
ten_zeros

"""### Tensors datatypes
**NOTE:** 3 things to look out for:
1. Tensors not right datatype
2. Tensors not right shape
3. Tensors not on the right device
"""

# Float 32 tensor
float_32_tensor = torch.tensor([3.0, 6.0, 9.0],
                               dtype = None, #what datatype is the tensor
                               device=None, #what device the tensor is on, default is cpu, can use GPU with CUDA
                               requires_grad=False)
float_32_tensor.dtype

float_16_tensor = float_32_tensor.type(torch.float16)
float_16_tensor

"""### Getting informations from tensors

1. Tensors not right datatype => to get datatype from a tensor can use tensor.dtype
2. Tensors not right shape => to get shape from a tensor can usef tensor.shape
3. Tensors not on the right device => to get device from a tensor can use tensor.device
"""

some_tensor = torch.rand(3,4)
print(some_tensor)
print(f"datatype of tensor: {some_tensor.dtype}")
print(f"shape of tensor: {some_tensor.shape}")
print(f"device the tensor is on: {some_tensor.device}")

"""### Manipulating tensors (tensors operations)

Tensor operations include:
* Addition
* Substraction
* Multiplication
* Division
* Matrix multiplication
"""

# Create a tensor and add 10 to it
tensor = torch.tensor([1,2,3])
tensor + 10

# Multiply by ten
tensor * 10

# Substract by 10
tensor - 10

"""### Matrix multiplication
2 ways:
1. element wise like before
2. matrix multiplication (dot product)

2 main rules to perform matrix multiplication
1. The **inner dimensions** must match
see inner dimensions as number closest to @ symbol
* @ symbol is matmul function
* `(3,2) @ (3,2)` won't work
* `(2,3) @ (3,2)` will work
* `(3,2) @ (2,3)` will work
2. The resulting matrix as the shape of the **outer dimensions**:
* `(2,3) @ (3,2) => (2,2)`
* `(3,2) @ (2,3) => (3,3)`
* `(3,10) @ (10,3) => (3,3)`
"""

torch.matmul(torch.rand(3,2), torch.rand(3,2))
#return error mat1 and mat2 shapes cannot be multiplied (3x2 and 3x2)

# element wise multiplication
print(tensor, "*", tensor)
print(f"equals: {tensor * tensor}")

#matrix multiplication with torch.matmul function
torch.matmul(tensor, tensor)
#return 14 so 1*1 + 2*2 + 3*3

"""### Common errors in DL: shape errors"""

